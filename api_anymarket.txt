import requests
import json
from typing import Dict, Any, Optional, List
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class AnyMarketAPI:
    """Classe para interagir com a API do AnyMarket v2"""
    
    def __init__(self, token: str, sandbox: bool = False):
        self.token = token
        # Usar a URL correta da API v2
        if sandbox:
            self.base_url = "https://sandbox-api.anymarket.com.br/v2"
        else:
            self.base_url = "https://api.anymarket.com.br/v2"  # Produção
        
        self.headers = {
            "gumgaToken": token,
            "Accept": "application/json",
            "Content-Type": "application/json"
        }
        logger.info(f"API AnyMarket v2 inicializada - Sandbox: {sandbox}")
    
    def buscar_fotos_produto(self, product_id: str) -> Dict[str, Any]:
        """
        Busca fotos de um produto específico
        ENDPOINT: GET /products/{productId}/images
        """
        try:
            url = f"{self.base_url}/products/{product_id}/images"  # ENDPOINT CORRETO
            
            logger.info(f"Consultando imagens do produto: {product_id}")
            
            response = requests.get(url, headers=self.headers, timeout=60)
            
            resultado = {
                "sucesso": response.status_code == 200,
                "status_code": response.status_code,
                "product_id": product_id,
                "timestamp": datetime.now().isoformat(),
                "url_consultada": url,
                "sandbox": "sandbox" in self.base_url
            }
            
            if response.status_code == 200:
                dados = response.json()
                fotos_processadas = self._processar_fotos_v2(dados)
                
                resultado["dados"] = fotos_processadas
                resultado["quantidade_fotos"] = len(fotos_processadas)
                
                logger.info(f"Consulta bem-sucedida - {resultado['quantidade_fotos']} imagens encontradas")
            
            elif response.status_code == 401:
                resultado["erro"] = "Erro de autenticação (401) - Token inválido"
            elif response.status_code == 404:
                resultado["erro"] = "Produto não encontrado (404)"
            else:
                resultado["erro"] = f"Erro HTTP {response.status_code}"
                resultado["detalhes_erro"] = response.text[:500]
            
            return resultado
            
        except Exception as e:
            logger.error(f"Erro inesperado: {str(e)}")
            return {
                "sucesso": False,
                "erro": f"Erro inesperado: {str(e)}",
                "product_id": product_id,
                "timestamp": datetime.now().isoformat()
            }
    
    def excluir_foto(self, product_id: str, photo_id: str) -> Dict[str, Any]:
        """
        Exclui uma foto específica de um produto
        ENDPOINT: DELETE /products/{productId}/images/{imageId}
        """
        try:
            url = f"{self.base_url}/products/{product_id}/images/{photo_id}"  # ENDPOINT CORRETO
            
            logger.info(f"Excluindo imagem - Produto: {product_id}, Imagem: {photo_id}")
            
            response = requests.delete(url, headers=self.headers, timeout=30)
            
            resultado = {
                "sucesso": response.status_code in [200, 204],
                "status_code": response.status_code,
                "product_id": product_id,
                "photo_id": photo_id,
                "timestamp": datetime.now().isoformat(),
                "url_consultada": url
            }
            
            if response.status_code in [200, 204]:
                logger.info(f"Imagem excluída com sucesso - Produto: {product_id}, Imagem: {photo_id}")
            else:
                resultado["erro"] = f"Erro HTTP {response.status_code}"
                resultado["detalhes_erro"] = response.text[:500]
            
            return resultado
            
        except Exception as e:
            logger.error(f"Erro ao excluir imagem: {str(e)}")
            return {
                "sucesso": False,
                "erro": f"Erro ao excluir imagem: {str(e)}",
                "product_id": product_id,
                "photo_id": photo_id,
                "timestamp": datetime.now().isoformat()
            }
    
    def atualizar_foto(self, product_id: str, photo_id: str, index: int, main: bool) -> Dict[str, Any]:
        """
        Atualiza índice e/ou status principal de uma imagem
        ENDPOINT: PUT /products/{productId}/images
        """
        try:
            url = f"{self.base_url}/products/{product_id}/images"  # ENDPOINT CORRETO
            
            logger.info(f"Atualizando imagem - Produto: {product_id}, Imagem: {photo_id}, Index: {index}, Principal: {main}")
            
            # Dados conforme documentação
            dados_atualizacao = {
                "id": int(photo_id),  # ID da imagem (obrigatório)
                "index": index,       # Novo índice (obrigatório)
                "main": main          # Se é principal (obrigatório)
            }
            
            response = requests.put(url, headers=self.headers, json=dados_atualizacao, timeout=30)
            
            resultado = {
                "sucesso": response.status_code in [200, 204],
                "status_code": response.status_code,
                "product_id": product_id,
                "photo_id": photo_id,
                "index": index,
                "main": main,
                "timestamp": datetime.now().isoformat(),
                "url_consultada": url
            }
            
            if response.status_code in [200, 204]:
                logger.info(f"Imagem atualizada com sucesso - Produto: {product_id}, Imagem: {photo_id}")
            else:
                resultado["erro"] = f"Erro HTTP {response.status_code}"
                resultado["detalhes_erro"] = response.text[:500]
            
            return resultado
            
        except Exception as e:
            logger.error(f"Erro ao atualizar imagem: {str(e)}")
            return {
                "sucesso": False,
                "erro": f"Erro ao atualizar imagem: {str(e)}",
                "product_id": product_id,
                "photo_id": photo_id,
                "timestamp": datetime.now().isoformat()
            }
    
    def definir_foto_principal(self, product_id: str, photo_id: str) -> Dict[str, Any]:
        """
        Define uma imagem como principal
        """
        try:
            # Buscar o índice atual da imagem
            fotos = self.buscar_fotos_produto(product_id)
            if not fotos["sucesso"]:
                return fotos
            
            foto_alvo = next((f for f in fotos["dados"] if f["id"] == photo_id), None)
            if not foto_alvo:
                return {
                    "sucesso": False,
                    "erro": f"Imagem {photo_id} não encontrada no produto {product_id}",
                    "product_id": product_id,
                    "photo_id": photo_id,
                    "timestamp": datetime.now().isoformat()
                }
            
            index_atual = foto_alvo["index"]
            
            # Usar o método de atualização para definir como principal
            return self.atualizar_foto(
                product_id=product_id,
                photo_id=photo_id,
                index=index_atual,
                main=True
            )
            
        except Exception as e:
            logger.error(f"Erro ao definir imagem principal: {str(e)}")
            return {
                "sucesso": False,
                "erro": f"Erro ao definir imagem principal: {str(e)}",
                "product_id": product_id,
                "photo_id": photo_id,
                "timestamp": datetime.now().isoformat()
            }
    
    def reordenar_fotos(self, product_id: str, nova_ordem: List[Dict]) -> Dict[str, Any]:
        """
        Reordena as imagens de um produto
        Atualiza uma por uma usando o endpoint PUT /products/{productId}/images
        """
        try:
            resultados = []
            total_sucesso = 0
            total_erro = 0
            
            for novo_index, foto_info in enumerate(nova_ordem, start=1):
                # Buscar status principal atual para manter
                fotos = self.buscar_fotos_produto(product_id)
                if not fotos["sucesso"]:
                    continue
                
                foto_atual = next((f for f in fotos["dados"] if f["id"] == foto_info["id"]), None)
                main_atual = foto_atual["main"] if foto_atual else False
                
                # Atualizar cada imagem com novo índice
                resultado = self.atualizar_foto(
                    product_id=product_id,
                    photo_id=foto_info["id"],
                    index=novo_index,
                    main=main_atual
                )
                
                resultados.append(resultado)
                
                if resultado["sucesso"]:
                    total_sucesso += 1
                else:
                    total_erro += 1
            
            return {
                "sucesso": total_erro == 0,
                "status_code": 200 if total_erro == 0 else 207,
                "product_id": product_id,
                "total_processado": len(nova_ordem),
                "total_sucesso": total_sucesso,
                "total_erro": total_erro,
                "resultados": resultados,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Erro ao reordenar imagens: {str(e)}")
            return {
                "sucesso": False,
                "erro": f"Erro ao reordenar imagens: {str(e)}",
                "product_id": product_id,
                "timestamp": datetime.now().isoformat()
            }
    
    def _processar_fotos_v2(self, dados: list) -> list:
        """Processa os dados das imagens da API v2"""
        fotos_processadas = []
        
        for foto in dados:
            foto_processada = {
                "id": str(foto.get("id", "")),
                "index": foto.get("index", 0),
                "main": foto.get("main", False),
                "type": foto.get("type", "IMAGE"),
                "url": foto.get("url", ""),
                "original": self._extrair_url_imagem_v2(foto),
                "status": "disponivel",
                "variation": foto.get("variation", "")
            }
            
            fotos_processadas.append(foto_processada)
        
        # Ordenar por índice
        fotos_processadas.sort(key=lambda x: x["index"])
        
        return fotos_processadas
    
    def _extrair_url_imagem_v2(self, foto: dict) -> str:
        """Extrai a URL da imagem da API v2"""
        # Na API v2, a URL geralmente está no campo "url"
        if "url" in foto and foto["url"]:
            url = foto["url"]
            if self._eh_url_valida(url):
                return url
        
        # Também verificar outros campos possíveis
        campos_alternativos = ["original", "standard", "high", "medium", "small", "thumbnail"]
        
        for campo in campos_alternativos:
            if campo in foto and foto[campo]:
                url = foto[campo]
                if self._eh_url_valida(url):
                    return url
        
        return ""
    
    def _eh_url_valida(self, url: str) -> bool:
        """Verifica se é uma URL válida de imagem"""
        if not isinstance(url, str):
            return False
        
        if not (url.startswith('http://') or url.startswith('https://')):
            return False
        
        extensoes_imagem = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp']
        return any(ext in url.lower() for ext in extensoes_imagem)
    
    def excluir_fotos_planilha(self, caminho_planilha: str) -> Dict[str, Any]:
        """Exclui imagens baseado em uma planilha Excel"""
        try:
            import pandas as pd
            
            df = pd.read_excel(caminho_planilha, dtype={"ID_PRODUTO": str, "ID_IMG": str})
            
            df["ID_PRODUTO"] = df["ID_PRODUTO"].astype(str).str.replace(r"\.0$", "", regex=True).str.strip()
            df["ID_IMG"] = df["ID_IMG"].astype(str).str.replace(r"\.0$", "", regex=True).str.replace(".", "", regex=False).str.strip()
            
            resultados = []
            total_sucesso = 0
            total_erro = 0
            
            for _, row in df.iterrows():
                product_id = row["ID_PRODUTO"]
                photo_id = row["ID_IMG"]
                
                if not product_id or not photo_id or product_id == 'nan' or photo_id == 'nan':
                    continue
                
                resultado_exclusao = self.excluir_foto(product_id, photo_id)
                resultados.append(resultado_exclusao)
                
                if resultado_exclusao["sucesso"]:
                    total_sucesso += 1
                else:
                    total_erro += 1
            
            return {
                "sucesso": total_erro == 0,
                "total_processado": len(resultados),
                "total_sucesso": total_sucesso,
                "total_erro": total_erro,
                "resultados": resultados,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Erro ao processar planilha: {str(e)}")
            return {
                "sucesso": False,
                "erro": f"Erro ao processar planilha: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }

# Funções de interface
def consultar_api_anymarket(product_id: str, token: str = None, sandbox: bool = False) -> Dict[str, Any]:
    default_token = "259086916L259063550E1850844837445C175753283744500O259063550.I"
    api = AnyMarketAPI(token or default_token, sandbox)
    return api.buscar_fotos_produto(product_id)

def excluir_foto_anymarket(product_id: str, photo_id: str, token: str = None, sandbox: bool = False) -> Dict[str, Any]:
    default_token = "259086916L259063550E1850844837445C175753283744500O259063550.I"
    api = AnyMarketAPI(token or default_token, sandbox)
    return api.excluir_foto(product_id, photo_id)

def excluir_fotos_planilha_anymarket(caminho_planilha: str, token: str = None, sandbox: bool = False) -> Dict[str, Any]:
    default_token = "259086916L259063550E1850844837445C175753283744500O259063550.I"
    api = AnyMarketAPI(token or default_token, sandbox)
    return api.excluir_fotos_planilha(caminho_planilha)

def definir_foto_principal_anymarket(product_id: str, photo_id: str, token: str = None, sandbox: bool = False) -> Dict[str, Any]:
    default_token = "259086916L259063550E1850844837445C175753283744500O259063550.I"
    api = AnyMarketAPI(token or default_token, sandbox)
    return api.definir_foto_principal(product_id, photo_id)

def reordenar_fotos_anymarket(product_id: str, nova_ordem: List[Dict], token: str = None, sandbox: bool = False) -> Dict[str, Any]:
    default_token = "259086916L259063550E1850844837445C175753283744500O259063550.I"
    api = AnyMarketAPI(token or default_token, sandbox)
    return api.reordenar_fotos(product_id, nova_ordem)

def atualizar_foto_anymarket(product_id: str, photo_id: str, index: int, main: bool, token: str = None, sandbox: bool = False) -> Dict[str, Any]:
    default_token = "259086916L259063550E1850844837445C175753283744500O259063550.I"
    api = AnyMarketAPI(token or default_token, sandbox)
    return api.atualizar_foto(product_id, photo_id, index, main)